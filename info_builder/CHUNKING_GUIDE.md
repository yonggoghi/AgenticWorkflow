# HTML 청킹 처리 가이드

## 개요

product_crawler는 HTML을 직접 LLM에게 전달하여 상품 정보를 추출합니다. 긴 HTML은 자동으로 청크(chunk)로 나눠서 처리하여 LLM의 컨텍스트 제한을 극복합니다.

## 작동 방식

### 1. HTML 분할

긴 HTML은 상품 컨테이너 단위로 분할됩니다:

```python
# 기본 설정
chunk_size = 15000    # 청크 크기 (문자 수)
# HTML을 상품 단위로 확실하게 분할
```

### 2. 확실한 분할

HTML을 상품 컨테이너 단위로 확실하게 분할합니다:

1. **우선순위 1**: `prdid` 속성이 있는 요소 찾기
2. **우선순위 2**: `product`, `item`, `pass`, `card` 클래스 찾기
3. **Fallback**: 상품 컨테이너를 못 찾으면 단순 15,000자 단위 분할

**중요**: 각 청크가 15,000자를 초과하지 않도록 강제 제한
- 단일 상품 HTML이 15,000자 초과 시 → 강제 분할
- 청크 크기 초과 감지 시 → 경고 출력

### 3. LLM이 직접 추출

LLM에게 HTML을 주고 다음을 모두 찾도록 합니다:

- **상품 ID**: HTML 속성이나 URL에서 직접 추출
- **상품명**: HTML 태그에서 추출
- **가격**: HTML에서 찾기
- **상세 URL**: 링크 속성에서 추출

**규칙 기반 파싱이 아닌 LLM의 이해력을 활용합니다.**

### 4. 중복 제거

각 청크에서 추출된 상품 정보는 자동으로 중복 제거됩니다:

```python
# ID + 상품명 + 가격으로 중복 체크
product_key = product.get('id', '') + '|||' + product.get('name', '') + '|||' + product.get('price', '')
```

## 예시

### 입력

웹 페이지 HTML: 156,000 문자

```
[1단계] 목록 페이지 크롤링
  페이지 로딩: https://...
  HTML: 156000 문자
  링크: 1 개

[2단계] 상품/서비스 정보 추출
  HTML을 3개 청크로 분할
  청크 1/3 처리 중... (50000 문자)
    → 60개 상품 발견 (총 60개)
  청크 2/3 처리 중... (53000 문자)
    → 62개 상품 발견 (총 122개)
  청크 3/3 처리 중... (53000 문자)
    → 60개 상품 발견 (총 182개)
  총 182개의 고유 상품/서비스를 추출했습니다.
  175개 상품에 ID가 포함되어 있습니다.
```

### 장점

1. **일반화**: 어떤 사이트에도 적용 가능 (규칙 의존 최소화)
2. **정확성**: LLM이 HTML 구조를 이해하고 ID 직접 추출
3. **완전성**: 긴 페이지의 모든 상품 정보 수집
4. **효율성**: 중복 제거로 불필요한 데이터 방지

## 설정 변경

청크 크기를 변경하고 싶다면 `product_crawler.py`를 수정하세요:

```python
# product_crawler.py, extract_products_with_llm 메서드

# 기본값 (권장)
html_chunks = self._chunk_html(html_content, chunk_size=15000)

# 더 작은 청크 (더 안전하지만 느림)
html_chunks = self._chunk_html(html_content, chunk_size=10000)

# 더 큰 청크 (빠르지만 응답이 잘릴 위험)
html_chunks = self._chunk_html(html_content, chunk_size=20000)
```

## 비용 고려사항

청크 수가 많아지면 LLM 호출 횟수가 증가합니다:

- **1개 청크**: 1번 LLM 호출
- **2개 청크**: 2번 LLM 호출
- **3개 청크**: 3번 LLM 호출

예상 비용:
- 청크당 약 $0.01-0.02 (모델에 따라 다름)
- 10,000자 페이지: 2청크 = $0.02-0.04

## 문제 해결

### 너무 많은 청크가 생성됨

```python
# chunk_size를 늘립니다
chunks = self._chunk_text(text_content, chunk_size=10000, overlap=500)
```

### JSON 파싱 오류가 계속 발생함

1. 청크 크기를 줄입니다
2. 프롬프트를 더 명확하게 수정합니다
3. 다른 LLM 모델을 시도합니다 (`--model gemini` 등)

### 중복된 상품이 여전히 나타남

중복 제거 로직을 강화하세요:

```python
# product_crawler.py에서
product_key = (
    product.get('name', '') + 
    product.get('price', '') + 
    product.get('id', '')
)
```

## 모니터링

실행 시 청킹 과정을 모니터링할 수 있습니다:

```
텍스트를 2개 청크로 분할
청크 1/2 처리 중... (8000 문자)
  → 5개 상품 발견 (총 5개)
청크 2/2 처리 중... (6107 문자)
  → 3개 상품 발견 (총 8개)
총 8개의 고유 상품/서비스를 추출했습니다.
```

이 정보를 통해:
- 청크가 잘 나뉘어졌는지
- 각 청크에서 상품을 찾았는지
- 중복 제거가 작동하는지
확인할 수 있습니다.

## 베스트 프랙티스

1. **첫 실행은 작은 페이지로 테스트**
   ```bash
   python product_crawler.py "simple-page.html" --scroll
   ```

2. **청크 크기 조정**
   - 일반 페이지: 15,000자 (기본값, 권장)
   - 짧은 페이지: 20,000자 (빠름)
   - 복잡하거나 JSON 오류 발생 시: 10,000자 (안전)

3. **모니터링**
   - 청크 수가 너무 많으면 (5개 이상) chunk_size 증가
   - JSON 오류가 많으면 chunk_size 감소

4. **비용 최적화**
   - 불필요한 텍스트 제거 (헤더, 푸터 등)
   - chunk_size를 최대한 크게 (but 안정성 유지)
   - 캐싱 활용 (같은 페이지 반복 크롤링 방지)

## 참고

- HTML 청킹은 목록 페이지에 적용됩니다
- 상세 페이지는 앞부분 8,000자만 사용 (상세 정보는 보통 처음에 있음)
- 중복 제거는 ID+상품명+가격 조합으로 수행됩니다
- **LLM이 HTML에서 직접 ID를 추출하므로 규칙 기반 매칭 불필요**

